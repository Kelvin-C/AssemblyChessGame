
AVRASM ver. 2.2.6  \\icnas2.cc.ic.ac.uk\ncc214\Desktop\Microprocessor\20160227-Chess - (afternoon)\AssemblerApplication1\AssemblerApplication1\main.asm Mon Feb 27 17:03:21 2017

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.0.106\avrasm\inc\m128def.inc'
\\icnas2.cc.ic.ac.uk\ncc214\Desktop\Microprocessor\20160227-Chess - (afternoon)\AssemblerApplication1\AssemblerApplication1\main.asm(6): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.0.106\avrasm\inc\m128def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.0.106\avrasm\inc\m128def.inc'
\\icnas2.cc.ic.ac.uk\ncc214\Desktop\Microprocessor\20160227-Chess - (afternoon)\AssemblerApplication1\AssemblerApplication1\main.asm(6): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.0.106\avrasm\inc\m128def.inc'
                                 
                                 ;**  ATmega128(L) Assembly Language File - IAR Assembler Syntax **
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;
                                 .DEVICE ATmega128
                                 
                                 ;*************************************************************************
                                 .include "m128def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 		
000000 940c 0133                 		jmp Init		    ; jmp is 2 word instruction to set correct vector
000002 0000
000003 9518                      		nop reti			; External 0 interrupt  Vector 
000004 0000
000005 9518                      		nop reti			; External 1 interrupt  Vector 
000006 0000
000007 9518                      		nop reti			; External 2 interrupt  Vector 
000008 0000
000009 9518                      		nop reti			; External 3 interrupt  Vector 
00000a 0000
00000b 9518                      		nop reti			; External 4 interrupt  Vector 
00000c 0000
00000d 9518                      		nop reti			; External 5 interrupt  Vector 
00000e 0000
00000f 9518                      		nop reti			; External 6 interrupt  Vector 
000010 0000
000011 9518                      		nop reti			; External 7 interrupt  Vector 
000012 0000
000013 9518                      		nop reti			; Timer 2 Compare Vector 
000014 0000
000015 9518                      		nop reti			; Timer 2 Overflow Vector 
000016 0000
000017 9518                      		nop reti			; Timer 1 Capture  Vector 
000018 0000
000019 9518                      		nop reti			; Timer1 CompareA  Vector 
00001a 0000
00001b 9518                      		nop reti			; Timer 1 CompareB  Vector 
00001c 0000
00001d 9518                      		nop reti			; Timer 1 Overflow  Vector 
00001e 940c 018b                 		jmp TIM0_COMP		; Timer 0 Compare  Vector 
000020 0000
000021 9518                      		nop reti			; Timer 0 Overflow interrupt  Vector 
000022 0000
000023 9518                      		nop reti			; SPI  Vector 
000024 0000
000025 9518                      		nop reti			; UART Receive  Vector 
000026 0000
000027 9518                      		nop reti			; UDR Empty  Vector 
000028 0000
000029 9518                      		nop reti			; UART Transmit  Vector 
00002a 0000
00002b 9518                      		nop reti			; ADC Conversion Complete Vector 
00002c 0000
00002d 9518                      		nop reti			; EEPROM Ready Vector 
00002e 0000
00002f 9518                      		nop reti			; Analog Comparator  Vector 
                                 
                                 .org		$0080			; start address well above interrupt table
                                 ;**************************************************************************
                                 ;r16 to r23 are TempRegs
                                 .def x_shift	= r24 
                                 .def y_shift	= r25 
                                 
000080 c0b2                      RJMP Init
                                 ;*************************************************************************											 
                                 ;port B = x axis, channel 1
                                 ;port D = y axis, channel 2
                                 
                                 X_table: ;X table [y_n, x_n ..., y1, x1]. {ld rd, -X}: load from (x1, y1), voltages length = [12-119] = 108
                                 ;1) K [1-32]
                                 ;2) Q [33-56]
                                 ;3) B [57-78]
                                 ;4) N [79-102]
                                 ;5) R [103-134]
                                 ;6) P [135-160]
                                 ;7) Player 1 message [161-169]
                                 ;8) voltages for circle (combined sine and cosine) [170-193]
                                 ;9) voltages for triangle [194-229]
                                 ;10) voltages for square [230-253]
000081 8286
000082 8280
000083 8280
000084 807d
000085 7d7a
000086 7d7a
000087 807d
000088 8280
000089 8280
00008a 8083
00008b 7d86
00008c 7d86
00008d 8083
00008e 8280
00008f 8280                      .db 134, 130, 128, 130, 128, 130, 125, 128, 122, 125, 122, 125, 125, 128, 128, 130, 128, 130, 131, 128, 134, 125, 134, 125, 131, 128, 128, 130, 128, 130, 122, 130,\
000090 827a
000091 7a85
000092 7c84
000093 7e82
000094 8081
000095 7d83
000096 8283
000097 8283
000098 827a
000099 827a
00009a 7d7a
00009b 7d7a                      133, 122, 132, 124, 130, 126, 129, 128, 131, 125, 131, 130, 131, 130, 122, 130, 122, 130, 122, 125, 122, 125, 131, 125,\
00009c 7d83
00009d 8286
00009e 7d82
00009f 7d82
0000a0 8280
0000a1 8280
0000a2 7d7d
0000a3 7d7d
0000a4 827a
0000a5 827a
0000a6 8280                      134, 130, 130, 125, 130, 125, 128, 130, 128, 130, 125, 125, 125, 125, 122, 130, 122, 130, 128, 130, 134, 130,\
0000a7 8286
0000a8 7d7a
0000a9 7d7e
0000aa 7d82
0000ab 7d86
0000ac 7d86
0000ad 7f82
0000ae 807e
0000af 827a
0000b0 827a
0000b1 827e
0000b2 8282                      122, 125, 126, 125, 130, 125, 134, 125, 134, 125, 130, 127, 126, 128, 122, 130, 122, 130, 126, 130, 130, 130, 134, 130,\
0000b3 8286
0000b4 7d86
0000b5 8083
0000b6 8280
0000b7 8280
0000b8 8080
0000b9 7d80
0000ba 7d80
0000bb 7d7d
0000bc 7d7a
0000bd 7d7a
0000be 807a
0000bf 827a
0000c0 8286
0000c1 8282
0000c2 827e                      134, 125, 131, 128, 128, 130, 128, 130, 128, 128, 128, 125, 128, 125, 125, 125, 122, 125, 122, 125, 122, 128, 122, 130, 134, 130, 130, 130, 126, 130, 122, 130,\
0000c3 827a
0000c4 8280
0000c5 8080
0000c6 7d80
0000c7 7d80
0000c8 7d7d
0000c9 7d7a
0000ca 7d7a
0000cb 807a
0000cc 827a
0000cd 8286
0000ce 8282
0000cf 827e                      128, 130, 128, 128, 128, 125, 128, 125, 125, 125, 122, 125, 122, 125, 122, 128, 122, 130, 134, 130, 130, 130, 126, 130, 122, 130,\
0000d0 827a
0000d1 3120
0000d2 7220
0000d3 7965
0000d4 6c61                      ' ','1',' ','r','e','y','a','l','P',\
0000d5 8850
0000d6 857a
0000d7 8077
0000d8 7a75
0000d9 7777
0000da 757a
0000db 7780
0000dc 7a85
0000dd 8088
0000de 858a
0000df 8888
0000e0 8a85                      136, 122, 133, 119, 128, 117, 122, 119, 119, 122, 117, 128, 119, 133, 122, 136, 128, 138, 133, 136, 136, 133, 138, 128,\
0000e1 8a80
0000e2 8a8b
0000e3 8a86
0000e4 8a82
0000e5 8a7e
0000e6 8a7a
0000e7 8b75
0000e8 8675
0000e9 8278
0000ea 7e7a
0000eb 7a7c
0000ec 757e
0000ed 7581
0000ee 7a80
0000ef 7e82
0000f0 8284
0000f1 8686
0000f2 8b88                      138, 139, 138, 134, 138, 130, 138, 126, 138, 122, 138, 117, 139, 117, 134, 120, 130, 122, 126, 124, 122, 126, 117, 129, 117, 128, 122, 130, 126, 132, 130, 134, 134, 136, 139, 139,\
0000f3 8b8b
0000f4 8075
0000f5 7575
0000f6 8a75
0000f7 8a75
0000f8 8a80
0000f9 8b8b
0000fa 808a
0000fb 758a
0000fc 758a
0000fd 758b
0000fe 7580
\\icnas2.cc.ic.ac.uk\ncc214\Desktop\Microprocessor\20160227-Chess - (afternoon)\AssemblerApplication1\AssemblerApplication1\main.asm(64): warning: .cseg .db misalignment - padding zero byte
0000ff 0075                      139, 117, 128, 117, 117, 117, 138, 117, 138, 128, 138, 139, 139, 138, 128, 138, 117, 138, 117, 139, 117, 128, 117, 117
                                 
                                 ;*************************************************************************
                                 Y_table: ;Y table
                                 ;1) flag to indicate whether piece is first move or captured; 0 = after 1st move, 1 = captured, 2 = first move [1-32] 
                                 ;2) voltage shifts for circles (flipped) -> [y_n, x_n ..., y1, x1]. ->-> (1 King, 1 Queen, 2 Bishops, 2 Knights, 2 Rooks, 8 Pawns) ->-> ;[33-64]
                                 ;3) voltage shifts for triangles (flipped) -> [y_n, x_n ..., y1, x1]  ;[65-96]
                                 ;4) voltage shifts for square (cursor) ;[97-98]
                                 ;5) index for x-coordinate of selected chess piece ;[99]
                                 ;6) value for flag, 0 = select piece; 1 = move piece ;[100]
                                 ;7) value for flag, 1 = player 1; 2 = player 2 ;[101]
                                 ;8) emoticon flag, 0 = no face, 1 = sad face [102]
000100 0002
000101 0000
000102 0000
000103 0202
000104 0202
000105 0202
000106 0202
000107 0202
000108 0002
000109 0000
00010a 0000
00010b 0202
00010c 0202
00010d 0202
00010e 0202                      .db 2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,\
00010f 0202
000110 00be
000111 16be
000112 eabe
000113 2cbe
000114 d4be
000115 42be
000116 bebe
000117 58be
000118 bed4
000119 d4d4
00011a ead4
00011b 00d4
00011c 16d4
00011d 2cd4
00011e 42d4                      -66, 0, -66, 22, -66, -22, -66, 44, -66, -44, -66, 66, -66, -66, -66, 88, -44, -66, -44, -44, -44, -22, -44, 0, -44, 22, -44, 44, -44, 66, -44, 88,\
00011f 58d4
000120 0058
000121 1658
000122 ea58
000123 2c58
000124 d458
000125 4258
000126 be58
000127 5858
000128 be42
000129 d442
00012a ea42
00012b 0042
00012c 1642
00012d 2c42
00012e 4242                      88, 0, 88, 22, 88, -22, 88, 44, 88, -44, 88, 66, 88, -66, 88, 88, 66, -66, 66, -44, 66, -22, 66, 0, 66, 22, 66, 44, 66, 66, 66, 88,\
00012f 5842                      0,0, \
000130 0000                      0,\
                                 0,\
000131 0000                      1,\
000132 0001                      0		
                                 
                                 ;*************************************************************************
                                 Init:                
                                 		; **** Stack Pointer Setup Code ****
                                 		; Stack Pointer Setup 
000133 e00f                      		ldi r16,$0F
000134 bf0e                      		out SPH,r16		; Stack Pointer High Byte 
000135 ef0f                      		ldi r16, $FF	; Stack Pointer Setup 
000136 bf0d                      		out SPL,r16		; Stack Pointer Low Byte 
                                                                   
                                    		; **** RAMPZ Setup Code ****  
000137 e000                      		ldi  r16, $00		; 1 = EPLM acts on upper 64K
000138 bf0b                      		out RAMPZ, r16		; 0 = EPLM acts on lower 64K
                                 
                                 		; ******* Sleep Mode And SRAM  *******
000139 ec00                      		ldi r16, $C0		; Idle Mode - SE bit in MCUCR not set
00013a bf05                      		out MCUCR, r16		; External SRAM Enable Wait State Enabled
                                    
                                 		; ******* Comparator Setup Code ****  
00013b e800                      		ldi r16,$80			; Comparator Disabled, Input Capture Disabled 
00013c b908                      		out ACSR, r16		; Comparator Settings
                                 
                                 		; **** Timer0 Setup Code ****  
00013d e00c                      		ldi r16,$0C			; Timer 0 Setup
00013e bf03                      		out TCCR0, r16		; Timer - PRESCALE TCK0 BY 256
                                 							; (devide the 8 Mhz clock by 256)
                                 							; clear timer on OCR0 match
00013f ef0f                      		ldi r16,$FF			; load OCR0 with n=255
000140 bf01                      		out OCR0,r16		; The counter will go every n*64*125 nsec
                                                                
                                 		; **** Interrupts Setup Code ****  
000141 e002                      		ldi r16, $02		; OCIE0
000142 bf07                      		out TIMSK, r16		; T0: Output compare match 
                                 		
                                         ; ******* Port A Setup Code ****  (LCD)
000143 ef0f                      		ldi r16, $FF		; 
000144 bb0a                      		out DDRA, r16		; Port A Direction Register
000145 e000                      		ldi r16, $00		; Init value 
000146 bb0b                      		out PORTA, r16		; Port A value
                                    
                                 		; ******* Port B Setup Code ****  (Channel 1)
000147 ef0f                      		ldi r16, $FF		; 
000148 bb07                      		out DDRB , r16		; Port B Direction Register
000149 e000                      		ldi r16, $00		; Init value 
00014a bb08                      		out PORTB, r16		; Port B value
                                    
                                 		; ******* Port C Setup Code ****  (LCD)
00014b ef0f                      		ldi r16, $FF		; Address AD15 to AD8
00014c bb05                      		out PORTC, r16		; Port C value
                                    
                                 		; ******* Port D Setup Code ****  (Channel 2)
00014d ef0f                      		ldi r16, $FF		; 
00014e bb01                      		out DDRD, r16		; Port D Direction Register
00014f e000                      		ldi r16, $00		; Init value 
000150 bb02                      		out PORTD, r16		; Port D value
                                    
                                 		;******* Port E setup Code ****  (Keypad)
000151 ef00                      		ldi r16, $F0		; 0-3 output, 4-7 input
000152 b902                      		out DDRE, r16		; Port E Direction Register
000153 e00f                      		ldi r16, $0F		; Init value 
000154 b903                      		out PORTE, r16		; Port E value
                                                                    
000155 9478                      		sei					; Enable All Interrupts 
                                  
000156 d06e                      		rcall init_X_table
000157 d078                      		rcall init_Y_table
000158 d002                      		rcall Idisp
000159 d060                      		rcall LCDMessage_out
00015a c080                      		rjmp main
                                 
                                 ;*******************************************************************************
                                 ; Display Initialization routine
                                 ; Follow the White-Red Book of Hitachi.
                                 ; Hitachi Liquid Crystal Disply LCD Initialization Sequence.
                                 ;
                                 Idisp:		
00015b d3ee                      		RCALL DEL10ms            ;wait 10ms for things to relax after power up           
00015c e300                      		ldi r16, $30	         
00015d 9300 8000                 		sts   $8000,r16
00015f d3ef                      		RCALL DEL4P1ms           ;wait 4.1 msec according to Hitachi
000160 9300 8000                 		sts   $8000,r16	        
000162 d3f1                      		rcall DEL100mus          ;wait 100 mus
000163 9300 8000                 		sts   $8000,r16	         
000165 d01f                      		rcall busylcd		
000166 e30f                      		ldi r16, $3F	         ;Function Set : 2 lines + 5x7 Font
000167 9300 8000                 		sts  $8000,r16
000169 d01b                      		rcall busylcd
00016a e008                      		ldi r16,  $08	         ;display off
00016b 9300 8000                 		sts  $8000, r16
00016d d017                      		rcall busylcd		
00016e e001                      		ldi r16,  $01	         ;display on
00016f 9300 8000                 		sts  $8000,  r16
000171 d013                      		rcall busylcd
000172 e308                      		ldi r16, $38			 ;function set
000173 9300 8000                 		sts  $8000, r16
000175 d00f                      		rcall busylcd
000176 e00e                      		ldi r16, $0E			 ;display on
000177 9300 8000                 		sts  $8000, r16
000179 d00b                      		rcall busylcd
00017a e006                      		ldi r16, $06				;entry mode set increment no shift
00017b 9300 8000                 		sts  $8000,  r16
00017d d007                      		rcall busylcd
00017e 2700                              clr r16
00017f 9508                              ret
                                 ;
                                 ;**********************************************************************************
                                 ; This clears the display so we can start all over again
                                 ;
                                 CLRDIS:
000180 e001                      	    ldi r16,$01		; Clear Display send cursor 
000181 9300 8000                 		sts $8000,r16   ; to the most left position
000183 d001                      		rcall busylcd
000184 9508                              ret
                                 ;**********************************************************************************
                                 ;   
                                 busylcd:        
000185 9100 8000                         lds r16, $8000   ;access 
000187 fd07                              sbrc r16, 7      ;check busy bit  7
000188 cffc                              rjmp busylcd
000189 d3ca                              rcall DEL100mus
00018a 9508                              ret              ;return if clear
                                 ;*************************************************************************
                                 
                                 TIM0_COMP:
00018b b64f                      		in R4,SREG		; save Sreg
00018c 9573                      		inc r23			; increment cycle
00018d 3370                      		cpi r23,$30		; compare cycle with 200 -> total time = n(FF)*64(0C)*125 *$30(r23) ns = 99ms
00018e f549                      		brne TIM0_COMP_ret	; if r23 = 48 jump to TIM0_COMP_ret
00018f 2777                      		clr r23 		; clear cycle and start counting 
                                 
                                 		/***sequence of pushes to save register before using keypad functions. Sequence of pops to restore the registers after keypad functions.***/
000190 930f                      		push r16
000191 931f                      		push r17
000192 932f                      		push r18
000193 933f                      		push r19
000194 934f                      		push r20
000195 935f                      		push r21
000196 936f                      		push r22
000197 938f                      		push r24
000198 939f                      		push r25
000199 93af                      		push r26
00019a 93bf                      		push r27
00019b 93cf                      		push r28
00019c 93df                      		push r29
00019d 93ef                      		push r30
00019e 93ff                      		push r31
00019f 920f                      		push r0
0001a0 efad                      		ldi r26,$FD	;reset
0001a1 e0b5                      		ldi r27,$05 ;X
0001a2 e6c6                      		ldi r28,$66 ;reset
0001a3 e0d1                      		ldi r29,$01 ;Y
0001a4 e0e0                      		ldi r30,0	;reset
0001a5 e0f0                      		ldi r31,0	;Z
0001a6 940e 02a7                 		call in_IO1		;Call keypad functions. 
0001a8 900f                      		pop r0
0001a9 91ff                      		pop r31
0001aa 91ef                      		pop r30
0001ab 91df                      		pop r29
0001ac 91cf                      		pop r28
0001ad 91bf                      		pop r27
0001ae 91af                      		pop r26
0001af 919f                      		pop r25
0001b0 918f                      		pop r24
0001b1 916f                      		pop r22
0001b2 915f                      		pop r21
0001b3 914f                      		pop r20
0001b4 913f                      		pop r19
0001b5 912f                      		pop r18
0001b6 911f                      		pop r17
0001b7 910f                      		pop r16
                                 		
                                 TIM0_COMP_ret:
0001b8 be4f                      		out SREG,r4		; restore sreg	
0001b9 9518                      		reti			; Timer 0 Overflow interrupt code here 
                                 
                                 ;*************************************************************************											 
                                 
                                 LCDMessage_Out:
0001ba e029                              LDI r18, 9	;length of messages in X table
0001bb 55a4                      		subi XL, 84	;length of square/circle/triangle part of X table
                                 
                                 LCDMessage_More:
0001bc 911e                      		ld r17, -X
0001bd 9310 c000                 		sts $C000, r17 ;display letter on LCD
0001bf dfc5                      		rcall busylcd
0001c0 952a                      		dec r18
0001c1 f009                      		breq LCDMessage_End
0001c2 cff9                      		rjmp LCDMessage_More
                                 
                                 LCDMessage_End:  	  
0001c3 5aa3                      		subi XL, -93	;reset X (+93)
0001c4 9508                      		ret          
                                 
                                 ;*************************************************************************											 
                                 init_X_table:	;Store 'X_table' into SRAM and make X register point to the table.
0001c5 ef0d                      		ldi r16, 253	; length of X_table
0001c6 e0e2                      		ldi ZL, low(X_table*2)
0001c7 e0f1                      		ldi ZH, high(X_table*2)
                                 		.equ init_X_address = $0500
0001c8 e0a0                      		ldi XL, low(init_X_address)
0001c9 e0b5                      		ldi XH, high(init_X_address)
                                 
                                 init_X_table_loop:	;load 8-bit number at address to R0, store number into Y+
0001ca 95c8                      		lpm			;move one byte from PM to r0; Check Assembly 3 - page 28
0001cb 920d                      		st X+,r0	;store in SRAM (and increment)
0001cc 95e3                      		inc ZL
0001cd 950a                      		dec r16		;count down bytes copied
0001ce f7d9                      		brne init_X_table_loop
0001cf 9508                      		ret
                                 
                                 ;*************************************************************************											 
                                 init_Y_table:	;Store 'Y_table' into SRAM and make Y register point to the table.
0001d0 e606                      		ldi r16, 102; length of Y_table
0001d1 e0e0                      		ldi ZL, low(Y_table*2)
0001d2 e0f2                      		ldi ZH, high(Y_table*2)
                                 		.equ init_Y_address = $0100
0001d3 e0c0                      		ldi YL, low(init_Y_address)
0001d4 e0d1                      		ldi YH, high(init_Y_address)
                                 
                                 init_Y_table_loop:	;load 8-bit number at address to R0, store number into Y+
0001d5 95c8                      		lpm			; move one byte from PM to r0; Check Assembly 3 - page 28
0001d6 9209                      		st Y+,r0	; store in SRAM (and increment)
0001d7 95e3                      		inc ZL
0001d8 950a                      		dec r16		; count down bytes copied
0001d9 f7d9                      		brne init_Y_table_loop
0001da 9508                      		ret
                                 	
                                 ;****************************** MAIN ********************************************
                                 main:
0001db d001                      		rcall loadtableY
0001dc cffe                      		rjmp main
                                 
                                 ;************************ PLOT OSCILLOSCOPE *************************************	
                                 
                                 ;********* LOAD TABLE Y **************							 
                                 loadtableY:
0001dd 50c4                      		subi YL, 4		;Shift Y to x-coordinate of square
0001de 918a                      		ld x_shift, -Y
0001df 919a                      		ld y_shift, -Y
0001e0 e322                      		ldi r18, 50		;no of times to redraw square
0001e1 d002                      		rcall drawsquare
0001e2 e200                      		ldi r16, 32		;no of chess pieces
0001e3 c004                      		rjmp loadtableY_loop
                                 
                                 drawsquare:
0001e4 d09e                      		rcall loadsquare
0001e5 952a                      		dec r18
0001e6 f7e9                      		brne drawsquare
0001e7 9508                      		ret
                                 
                                 loadtableY_loop:
0001e8 e440                      		ldi r20, 64		;total no. of coordinates of all pieces
                                 
                                 loadtableY_loop_cont:
0001e9 e027                      		ldi r18, 7		;no of times to redraw each triangle/circle
0001ea 1bc4                      		sub YL, r20		;shift Y to the flag of the piece (to see if it's captured)
0001eb 915a                      		ld r21, -Y		
0001ec 0fc4                      		add YL, r20		;reset
0001ed 5fcf                      		subi YL, $FF	;Y
0001ee 954a                      		dec r20			
0001ef 3051                      		cpi r21, 1		;if piece is captured (i.e. flag = 1)
0001f0 f051                      		breq skipdraw	;do not draw piece
0001f1 918a                      		ld x_shift, -Y
0001f2 919a                      		ld y_shift, -Y	
                                 		
                                 redraw_loop:
0001f3 e063                      		ldi r22, 3			;number of times to redraw letter per redraw shape loop (total number of times redrawing each letter = r22*r18)
0001f4 d008                      		rcall loadtableX	;draw piece
0001f5 952a                      		dec r18
0001f6 f7e1                      		brne redraw_loop	;stops drawing after r18 number of times
                                 
                                 redraw_loop_cont:			;ran when after a piece/letter has finished drawing
0001f7 950a                      		dec r16				
0001f8 f781                      		brne loadtableY_loop_cont	;loops this function until all pieces are drawn
0001f9 5bca                      		subi YL, $BA		;shift pointer X by +70 (reset)
0001fa 9508                      		ret					;jump back to main
                                 
                                 skipdraw:
0001fb 50c2                      		subi YL, 2			;skip the x,y-coordinates of current piece if it's captured
0001fc cffa                      		rjmp redraw_loop_cont
                                 
                                 
                                 ;********* LOAD TABLE X **************	
                                 loadtableX:
0001fd 3101                      		cpi r16, 17					;check if it is currently drawing player 1 or 2 pieces. (r16 > 16 is player 1)
0001fe f40c                      		brge before_loadtriangle	;draw triangle for player 1
0001ff c00c                      		rjmp before_loadcircle		;draw circle for player 2
                                 
                                 before_loadtriangle:	;for player 1, this function will check what type of piece it needs to draw, and then it jumps to its corrsponding drawing function.
000200 3109                      		cpi r16, 25
000201 f4b4                      		brge draw_letter_pawn
000202 3107                      		cpi r16, 23
000203 f52c                      		brge draw_letter_rook
000204 3105                      		cpi r16, 21
000205 f5cc                      		brge draw_letter_knight
000206 3103                      		cpi r16, 19
000207 f5a4                      		brge jump_draw_letter_bishop
000208 3102                      		cpi r16, 18
000209 f199                      		breq jump_draw_letter_queen
00020a 3101                      		cpi r16, 17
00020b f191                      		breq jump_draw_letter_king
                                 
                                 before_loadcircle:		;for player 2, this function will check what type of piece it needs to draw, and then it jumps to its corrsponding drawing function.
00020c 3009                      		cpi r16, 9
00020d f454                      		brge draw_letter_pawn
00020e 3007                      		cpi r16, 7
00020f f4cc                      		brge draw_letter_rook
000210 3005                      		cpi r16, 5
000211 f56c                      		brge draw_letter_knight
000212 3003                      		cpi r16, 3
000213 f544                      		brge jump_draw_letter_bishop
000214 3002                      		cpi r16, 2
000215 f139                      		breq jump_draw_letter_queen
000216 3001                      		cpi r16, 1
000217 f131                      		breq jump_draw_letter_king
                                 
                                 draw_letter_pawn:
000218 55ad                      		subi XL, 93	;shift X to the voltages for the letter P
000219 e01d                      		ldi r17, 13 ;half the no of voltages in table X for pawn
                                 
                                 draw_letter_pawn_loop:
00021a 913e                      		ld r19, -X		 ;x-coordinate voltage of P
00021b 0f38                      		add r19, x_shift ;shifts the x voltage to the piece's x-coordinate
00021c bb38                      		out portb, r19   ;output new voltage to DAC/oscilloscope
                                 
00021d 913e                      		ld r19, -X		 ;y-coordinate voltage of P
00021e 0f39                      		add r19, y_shift ;shifts the y voltage to the piece's y-coordinate
00021f bb32                      		out portd, r19   ;output new voltage to DAC/oscilloscope
                                 
000220 951a                      		dec r17	
000221 f7c1                      		brne draw_letter_pawn_loop	;keeps drawing until P is fully drawn
000222 58a9                      		subi XL, -119				;shift pointer X by +119 (reset).
                                 
000223 956a                      		dec r22					
000224 f799                      		brne draw_letter_pawn	;repeat until the letter P has been drawn r22*r18 times
                                 
000225 3101                      		cpi r16, 17
000226 f4a4                      		brge jump_loadtriangle
000227 3101                      		cpi r16, 17
000228 f08c                      		brlt jump_loadcircle
                                 
                                 draw_letter_rook:
000229 57a7                      		subi XL, 119 ;shift X to the voltages for the letter R
00022a e110                      		ldi r17, 16  ;half the no of voltages in table X for rook
                                 
                                 draw_letter_rook_loop:
00022b 913e                      		ld r19, -X			;x-coordinate voltage of R
00022c 0f38                      		add r19, x_shift	;shifts the x voltage to the piece's x-coordinate
00022d bb38                      		out portb, r19		;output new voltage to DAC/oscilloscope
                                 
00022e 913e                      		ld r19, -X			;y-coordinate voltage of R
00022f 0f39                      		add r19, y_shift	;shifts the y voltage to the piece's y-coordinate
000230 bb32                      		out portd, r19		;output new voltage to DAC/oscilloscope
                                 
000231 951a                      		dec r17
000232 f7c1                      		brne draw_letter_rook_loop	;keeps drawing until R is fully drawn
000233 56a9                      		subi XL, -151				;shift pointer X by +151 (reset).
                                 
000234 956a                      		dec r22					
000235 f799                      		brne draw_letter_rook	;repeat until the letter P has been drawn r22*r18 times
                                 
000236 3101                      		cpi r16, 17
000237 f41c                      		brge jump_loadtriangle
000238 3101                      		cpi r16, 17
000239 f004                      		brlt jump_loadcircle
                                 
                                 jump_loadcircle:
00023a c05f                      		rjmp loadcircle
                                 
                                 jump_loadtriangle:
00023b c052                      		rjmp loadtriangle
                                 
                                 jump_draw_letter_bishop:
00023c c013                      		rjmp draw_letter_bishop
                                 
                                 jump_draw_letter_queen:
00023d c023                      		rjmp draw_letter_queen
                                 
                                 jump_draw_letter_king:
00023e c033                      		rjmp draw_letter_king
                                 
                                 draw_letter_knight:
00023f 59a7                      		subi XL, 151;shift X to the voltages for the letter N
000240 e01c                      		ldi r17, 12 ;half the no of voltages in table X for king
                                 
                                 draw_letter_knight_loop:
000241 913e                      		ld r19, -X			;x-coordinate voltage of N
000242 0f38                      		add r19, x_shift	;shifts the x voltage to the piece's x-coordinate
000243 bb38                      		out portb, r19		;output new voltage to DAC/oscilloscope
                                 
000244 913e                      		ld r19, -X			;y-coordinate voltage of N
000245 0f39                      		add r19, y_shift	;shifts the y voltage to the piece's y-coordinate
000246 bb32                      		out portd, r19		;output new voltage to DAC/oscilloscope
                                 
000247 951a                      		dec r17	
000248 f7c1                      		brne draw_letter_knight_loop ;keeps drawing until N is fully drawn
000249 55a1                      		subi XL, -175				 ;shift pointer X by +175 (reset).
                                 
00024a 956a                      		dec r22					
00024b f799                      		brne draw_letter_knight ;repeat until the letter P has been drawn r22*r18 times
                                 
00024c 3101                      		cpi r16, 17
00024d f76c                      		brge jump_loadtriangle
00024e 3101                      		cpi r16, 17
00024f f354                      		brlt jump_loadcircle
                                 
                                 draw_letter_bishop:
000250 5aaf                      		subi XL, 175		;shift X to the voltages for the letter B
000251 e01b                      		ldi r17, 11			;half the no of voltages in table X for B
                                 
                                 draw_letter_bishop_loop:
000252 913e                      		ld r19, -X			;x-coordinate voltage of B
000253 0f38                      		add r19, x_shift	;shifts the y voltage to the piece's x-coordinate
000254 bb38                      		out portb, r19		;output new voltage to DAC/oscilloscope
                                 
000255 913e                      		ld r19, -X			;y-coordinate voltage of B
000256 0f39                      		add r19, y_shift	;shifts the y voltage to the piece's y-coordinate
000257 bb32                      		out portd, r19		;output new voltage to DAC/oscilloscope
                                 
000258 951a                      		dec r17	
000259 f7c1                      		brne draw_letter_bishop_loop ;keeps drawing until P is fully drawn
00025a 53ab                      		subi XL, -197				 ;shift pointer X by +197 (reset).
                                 
00025b 956a                      		dec r22		
00025c f799                      		brne draw_letter_bishop ;repeat until the letter P has been drawn r22*r18 times
                                 
00025d 3101                      		cpi r16, 17
00025e f57c                      		brge loadtriangle
00025f 3101                      		cpi r16, 17
000260 f2cc                      		brlt jump_loadcircle
                                 
                                 draw_letter_queen:
000261 5ca5                      		subi XL, 197	 ;shift X to the voltages for the letter Q
000262 e01c                      		ldi r17, 12		 ;half the no of voltages in table X for Q
                                 
                                 draw_letter_queen_loop:
000263 913e                      		ld r19, -X		 ;x-coordinate voltage of Q
000264 0f38                      		add r19, x_shift ;shifts the x voltage to the piece's x-coordinate
000265 bb38                      		out portb, r19	 ;output new voltage to DAC/oscilloscope
                                 
000266 913e                      		ld r19, -X		 ;y-coordinate voltage of Q
000267 0f39                      		add r19, y_shift ;shifts the y voltage to the piece's y-coordinate
000268 bb32                      		out portd, r19	 ;output new voltage to DAC/oscilloscope
                                 
000269 951a                      		dec r17
00026a f7c1                      		brne draw_letter_queen_loop ;keeps drawing until Q is fully drawn
00026b 52a3                      		subi XL, -221				;shift pointer X by +221 (reset).
                                 
00026c 956a                      		dec r22		
00026d f799                      		brne draw_letter_queen ;repeat until the letter P has been drawn r22*r18 times
                                 
00026e 3101                      		cpi r16, 17
00026f f4f4                      		brge loadtriangle
000270 3101                      		cpi r16, 17
000271 f144                      		brlt loadcircle
                                 
                                 draw_letter_king:
000272 5dad                      		subi XL, 221 ;shift X to the voltages for the letter K
000273 e110                      		ldi r17, 16	 ;half the no of voltages in table X for K
                                 
                                 draw_letter_king_loop:
000274 913e                      		ld r19, -X			;x-coordinate voltage of K
000275 0f38                      		add r19, x_shift	;shifts the x voltage to the piece's x-coordinate
000276 bb38                      		out portb, r19		;output new voltage to DAC/oscilloscope
                                 
000277 913e                      		ld r19, -X			;y-coordinate voltage of K
000278 0f39                      		add r19, y_shift	;shifts the y voltage to the piece's y-coordinate
000279 bb32                      		out portd, r19		;output new voltage to DAC/oscilloscope
                                 
00027a 951a                      		dec r17	
00027b f7c1                      		brne draw_letter_king_loop ;keeps drawing until K is fully drawn
00027c 50a3                      		subi XL, -253				;shift pointer X by +253 (reset).
                                 
00027d 956a                      		dec r22		
00027e f799                      		brne draw_letter_king ;repeat until the letter P has been drawn r22*r18 times
                                 
00027f 3101                      		cpi r16, 17
000280 f46c                      		brge loadtriangle
000281 3101                      		cpi r16, 17
000282 f0bc                      		brlt loadcircle
                                 
                                 ;********** DRAW SHAPES ***************
                                 loadsquare:
000283 e01c                      		ldi r17, 12			;half the no of voltages in table X for square
                                 
                                 squareloop:
000284 913e                      		ld r19, -X			;x-coordinate voltage of square
000285 0f38                      		add r19, x_shift	;shifts the x voltage to the piece's x-coordinate
000286 bb38                      		out portb, r19		;output new voltage to DAC/oscilloscope
                                 
000287 913e                      		ld r19, -X			;y-coordinate voltage of square
000288 0f39                      		add r19, y_shift	;shifts the y voltage to the piece's y-coordinate
000289 bb32                      		out portd, r19		;output new voltage to DAC/oscilloscope
                                 
00028a 951a                      		dec r17
00028b f7c1                      		brne squareloop		;keeps drawing until square is fully drawn
00028c 5ea8                      		subi XL, -24		;shift pointer X by +24 (reset).
00028d 9508                      		ret
                                 
                                 loadtriangle:
00028e 51a8                      		subi XL, 24			;shift X to the voltages for the triangle
00028f e112                      		ldi r17, 18			;half the no of voltages in table X for triangle
                                 
                                 triangleloop:
000290 913e                      		ld r19, -X			;x-coordinate voltage of triangle
000291 0f38                      		add r19, x_shift	;shifts the x voltage to the piece's x-coordinate
000292 bb38                      		out portb, r19		;output new voltage to DAC/oscilloscope
                                 
000293 913e                      		ld r19, -X			;y-coordinate voltage of triangle
000294 0f39                      		add r19, y_shift	;shifts the y voltage to the piece's y-coordinate
000295 bb32                      		out portd, r19		;output new voltage to DAC/oscilloscope
                                 
000296 951a                      		dec r17
000297 f7c1                      		brne triangleloop	;keeps drawing until triangle is fully drawn
000298 5ca4                      		subi XL, -60		;shift pointer X by +60 (reset).
000299 9508                      		ret
                                 
                                 loadcircle:
00029a 53ac                      		subi XL, 60			;shift X to the voltages for the circle
00029b e01c                      		ldi r17, 12			;half the no of voltages in table X for circle
                                 
                                 circleloop:
00029c 913e                      		ld r19, -X			;x-coordinate voltage of circle
00029d 0f38                      		add r19, x_shift	;shifts the x voltage to the piece's x-coordinate
00029e bb38                      		out portb, r19		;output new voltage to DAC/oscilloscope
                                 
00029f 913e                      		ld r19, -X			;y-coordinate voltage of circle
0002a0 0f39                      		add r19, y_shift	;shifts the y voltage to the piece's y-coordinate
0002a1 bb32                      		out portd, r19		;output new voltage to DAC/oscilloscope
                                 
0002a2 951a                      		dec r17
0002a3 f7c1                      		brne circleloop		;keeps drawing until circle is fully drawn
0002a4 5aac                      		subi XL, -84		;shift pointer X by +84 (reset).
0002a5 9508                      		ret
                                 
                                 /********************************* KEYPAD ******************************************/
0002a6 9508                      return:	ret
                                 
                                 ;********* CHECK KEYPAD *************
                                 in_IO1:	
0002a7 d298                      		rcall IO1			;Change Port E such that 0-3 output, 4-7 input
0002a8 d2b0                      		rcall del5mus		;Delay is necessary to change direction of Port E
0002a9 b111                      		in r17, pine		;store input of Port E
0002aa 301f                      		cpi r17, $0F		;If a button is pressed, go to in_IO2
0002ab f3d1                      		breq return			;if not pressed, return back to interrupt function
                                 
                                 in_IO2:	
0002ac d298                      		rcall IO2			;Change Port E such that 0-3 input, 4-7 output
0002ad d2ab                      		rcall del5mus		;Delay is necessary to change direction of Port E
0002ae b121                      		in r18, pine		;store input of Port E
0002af 3f20                      		cpi r18, $F0		;If a button is pressed, compare
0002b0 f3a9                      		breq return			;if not pressed, return back to interrupt function
                                 
                                 compare:					;compare/subcompare functions detect which key is pressed based on the input values
0002b1 301e                      		cpi r17, $0E
0002b2 f039                      		breq subcompare0
0002b3 301d                      		cpi r17, $0D
0002b4 f069                      		breq subcompare1
0002b5 301b                      		cpi r17, $0B
0002b6 f0b1                      		breq subcompare2
0002b7 3017                      		cpi r17, $07
0002b8 f199                      		breq subcompare3
0002b9 9508                      		ret
                                 
                                 subcompare0:				;compare/subcompare functions detect which key is pressed based on the input values
0002ba 3e20                      		cpi r18, $E0
0002bb f009                      		breq c
0002bc 9508                      		ret
                                 
0002bd 50c3                      	c: 	subi YL, 3			;shift Y to select piece flag
0002be e020                      		ldi r18, 0			
0002bf 8328                      		st Y, r18			;set select flag to 0 (i.e. a piece is not selected)
0002c0 5fcd                      		subi YL, $FD		;reset Y
0002c1 9508                      		ret
                                 
                                 subcompare1:				;compare/subcompare functions detect which key is pressed based on the input values
0002c2 3b20                      		cpi r18, $B0
0002c3 f009                      		breq eight
0002c4 9508                      		ret
                                 
                                 eight: 	
0002c5 50c6                      		subi YL, 6			;shift Y to y-coordinate of square
0002c6 8128                      		ld r18, Y			;store y-coordinate of square
0002c7 e508                      		ldi r16, 88			
0002c8 1320                      		CPSE r18, r16		;if y-coordinate is 88, it is not changed because it is at the edge of the board
0002c9 5e2a                      		subi r18, $EA		;shifts the square down one grid by adding 22 (inverted Cartesian coordinates)
0002ca 8328                      		st Y, r18			;stores the new square y-coordinate
0002cb 5fca                      		subi YL, $FA		;reset Y
0002cc 9508                      		ret
                                 
                                 subcompare2:				;compare/subcompare functions detect which key is pressed based on the input values
0002cd 3720                      		cpi r18, $70
0002ce f029                      		breq four
0002cf 3d20                      		cpi r18, $D0
0002d0 f059                      		breq six
0002d1 3e20                      		cpi r18, $E0
0002d2 f089                      		breq e
0002d3 9508                      		ret
                                 
                                 four: 
0002d4 50c5                      		subi YL, 5			;shift Y to x-coordinate of square
0002d5 8128                      		ld r18, Y			;store x-coordinate of square
0002d6 e508                      		ldi r16, 88			
0002d7 1320                      		cpse r18, r16		;if x-coordinate is 88, it is not changed because it is at the edge of the board
0002d8 5e2a                      		subi r18, $EA		;shifts the square left one grid by adding 22 (inverted Cartesian coordinates)
0002d9 8328                      		st Y, r18			;stores the new square x-coordinate
0002da 5fcb                      		subi YL, $FB		;reset Y
0002db 9508                      		ret
                                 
0002dc 50c5                      six:	subi YL, 5			;shift Y to x-coordinate of square
0002dd 8128                      		ld r18, Y			;store x-coordinate of square
0002de eb0e                      		ldi r16, $BE		
0002df 1320                      		cpse r18, r16		;if x-coordinate is -66, it is not changed because it is at the edge of the board
0002e0 5126                      		subi r18, 22		;shifts the square right one grid by subtracting 22 (inverted Cartesian coordinates)
0002e1 8328                      		st Y, r18			;stores the new square x-coordinate
0002e2 5fcb                      		subi YL, $FB		;reset Y
0002e3 9508                      		ret
                                 
                                 e: 	
0002e4 50c1                      		subi YL, 1			;shfit Y to player flag
0002e5 918a                      		ld r24, -Y			;store player flag
0002e6 910a                      		ld r16, -Y			;shift Y and store select piece flag
0002e7 3000                      		cpi r16, 0			;to select a piece
0002e8 f079                      		breq select_piece
0002e9 3001                      		cpi r16, 1			;to move a piece
0002ea f061                      		breq jump_move_piece
0002eb 9508                      		ret
                                 
                                 subcompare3:				;compare/subcompare functions detect which key is pressed based on the input values
0002ec 3b20                      		cpi r18, $B0
0002ed f009                      		breq two
0002ee 9508                      		ret
                                 
                                 two: 
0002ef 50c6                      		subi YL, 6			;shift Y to y-coordinate of square
0002f0 8128                      		ld r18, Y			;store y-coordinate of square
0002f1 eb0e                      		ldi r16, $BE
0002f2 1320                      		cpse r18, r16		;if y-coordinate is -66, it is not changed because it is at the edge of the board
0002f3 5126                      		subi r18, 22		;shifts the square up one grid by subtracting 22 (inverted Cartesian coordinates)
0002f4 8328                      		st Y, r18			;stores the new square y-coordinate
0002f5 5fca                      		subi YL, $FA		;reset Y
0002f6 9508                      		ret
                                 
                                 /*********************** EXTENSION FROM E BUTTON *************************/
                                 
                                 jump_move_piece:
0002f7 c02d                      		rjmp move_piece
                                 
                                 ;********** SELECT PIECE **********
                                 select_piece:
0002f8 50c1                      		subi YL, 1		;shfit Y to player flag
0002f9 910a                      		ld r16, -Y		;load x voltage shift for square
0002fa 911a                      		ld r17, -Y		;load y voltage shift for square
0002fb e430                      		ldi r19, 64		;no of chess pieces *2 = total no. of their coordinates. r19 is a counter to show which piece is being compared
0002fc c002                      		rjmp e_compare_x
                                 
                                 e_return:
0002fd 5bca                      		subi YL, $BA; shift pointer Y by +70 (reset)
0002fe 9508                      		ret
                                 
                                 e_compare_x:
0002ff 912a                      		ld r18, -Y		;load x-coordinate of a piece
000300 953a                      		dec r19
                                 
000301 1702                      		cp r16, r18		;compare x voltage
000302 f021                      		breq e_compare_y	;if the square's x-coordinate is equal to a piece's x-coordinate, go to e_compare_y which compares their y-coordinates
                                 	
000303 50c1                      		subi YL, 1		;shift Y by 1 to skip the y-coordinate because their x-coordinates are not equal
000304 953a                      		dec r19
000305 f3b9                      		breq e_return	;if no pieces are found to be at the square's location, Y is reset and it jumps back to the interrupt function.
                                 
000306 cff8                      		rjmp e_compare_x ;loops this function until all pieces are compared
                                 	
                                 e_compare_y:
000307 953a                      		dec r19
000308 912a                      		ld r18, -Y			;load y-coordinate of a piece
                                 
000309 1712                      		cp r17, r18			;compare y voltage
00030a f019                      		breq store_piece	;if a piece is found to be at the square's location, the selected piece will be checked to see if it is legal to be selected.
00030b 3030                      		cpi r19, 0
00030c f381                      		breq e_return		;if no pieces are found to be at the square's location, Y is reset and it jumps back to the interrupt function.
00030d cff1                      		rjmp e_compare_x	;loops e_compare_x until all pieces are compared
                                 
                                 store_piece:
00030e 3230                      		cpi r19, 32			;checks to see if the selected piece is of player 1 or 2 (player 1's piece has r19 > 32)
00030f f40c                      		brge store_piece_check_player1
000310 c003                      		rjmp store_piece_check_player2
                                 
                                 store_piece_check_player1:
                                 ;r24 = player 1 or 2 flag. If the current player is player 1, then the index of the selected piece's x-coordinate will be stored. Otherwise, no piece is selected.
000311 3081                      		cpi r24, 1			
000312 f021                      		breq store_piece_coordinates
000313 c00e                      		rjmp store_piece_reject
                                 
                                 store_piece_check_player2:
                                 ;r24 = player 1 or 2 flag. If the current player is player 2, then the index of the selected piece's x-coordinate will be stored. Otherwise, no piece is selected.
000314 3082                      		cpi r24, 2			
000315 f009                      		breq store_piece_coordinates
000316 c00b                      		rjmp store_piece_reject
                                 
                                 store_piece_coordinates:
000317 5435                      		subi r19, 69		;r19 is now the negative of the index of the selected piece's x-coordinate
000318 9531                      		neg r19				;r19 is now the index of the selected piece's x-coordinate
000319 5fcf                      		subi YL, $FF		;reset 
00031a 0fc3                      		add YL, r19			;Y
00031b 50c3                      		subi YL, 3			;shift to select/move flag
00031c e021                      		ldi r18, 1			
00031d 8328                      		st Y, r18			;set select/move flag = 1
00031e 95ca                      		dec YL
00031f 8338                      		st Y, r19			;store index of the x-coordinate of the selected piece
000320 5fcc                      		subi YL, $FC		;reset Y
000321 9508                      		ret
                                 
                                 store_piece_reject:
000322 5436                      		subi r19, 70		;reset
000323 1bc3                      		sub YL, r19			;Y
000324 9508                      		ret
                                 
                                 ;********** MOVE PIECE ***************
                                 
                                 move_piece:
000325 910a                      		ld r16, -Y			;index of selected piece's x-coordinate from store_piece_coordinates function
000326 911a                      		ld r17, -Y			;x-coordinate of the square to be moved to
000327 912a                      		ld r18, -Y			;y-coordinate of the square to be moved to
000328 5fca                      		subi YL, $FA		;reset Y 
000329 1bc0                      		sub YL, r16			;shift to x-coordinate of selected chess piece
00032a 8138                      		ld r19, Y			;x-coordinate of chess piece before move
00032b 914a                      		ld r20, -Y			;y-coordinate of chess piece before move
00032c 2f63                      		mov r22, r19		;copying the "x-coordinate of chess piece before move" to a new register
00032d 2f74                      		mov r23, r20		;copying the "y-coordinate of chess piece before move" to a new register
00032e 1b31                      		sub r19, r17		;difference between x-coordinates
00032f 1b42                      		sub r20, r18		;difference between y-coordinates
                                 
                                 compare_chess_piece:
000330 3106                      		cpi r16, 22			;upper index for player 1 pawn
000331 f0b4                      		brlt pawn
000332 310a                      		cpi r16, 26			;upper index for player 1 rook
000333 f174                      		brlt jump_rook
000334 310e                      		cpi r16, 30			;upper index for player 1 knight	
000335 f16c                      		brlt jump_knight
000336 3202                      		cpi r16, 34			;upper index for player 1 bishop
000337 f164                      		brlt jump_bishop
000338 3204                      		cpi r16, 36			;upper index for player 1 queen
000339 f15c                      		brlt jump_queen
00033a 3206                      		cpi r16, 38			;upper index for player 1 king
00033b f154                      		brlt jump_king
00033c 3306                      		cpi r16, 54			;upper index for player 2 pawn
00033d f054                      		brlt pawn
00033e 330a                      		cpi r16, 58			;upper index for player 2 rook
00033f f114                      		brlt jump_rook
000340 330e                      		cpi r16, 62			;upper index for player 2 knight
000341 f10c                      		brlt jump_knight
000342 3402                      		cpi r16, 66			;upper index for player 2 bishop
000343 f104                      		brlt jump_bishop
000344 3404                      		cpi r16, 68			;upper index for player 2 queen
000345 f0fc                      		brlt jump_queen
000346 3406                      		cpi r16, 70			;upper index for player 2 king
000347 f0f4                      		brlt jump_king
                                 
                                 ;********* PAWN ***********
                                 pawn:
000348 5fcf                      		subi YL, $FF	;reset
000349 0fc0                      		add YL, r16		;Y
00034a 2f50                      		mov r21, r16	;copy the selected piece's x-coordinate index to r21
00034b 5057                      		subi r21, 7		
00034c 9556                      		lsr r21			;divide by 2 by shifting bits
00034d 5b59                      		subi r21, $B9	;plus 71
00034e 1bc5                      		sub YL, r21		;r21 is index of firstmove flag
00034f 8188                      		ld r24, Y		;chess piece first move flag
000350 0fc5                      		add YL, r21		;reset Y
000351 50c2                      		subi YL, 2		;shift Y to player flag
000352 8198                      		ld r25, Y		;load player flag to r25
000353 5fce                      		subi YL, $FE	;reset Y
                                 
000354 3030                      		cpi r19, 0			;check for forward movement
000355 f029                      		breq pawn_firstmove_check
000356 3136                      		cpi r19, 22			;diagonal movement
000357 f0c9                      		breq pawn_player_check
000358 3e3a                      		cpi r19, -22		;diagonal movement
000359 f0b9                      		breq pawn_player_check
00035a c1d4                      		rjmp reject_move	;reject move if illegal move
                                 
                                 pawn_firstmove_check:
00035b 3082                      		cpi r24, 2			;check first move
00035c f011                      		breq pawn_firstmove_player_check
00035d 3080                      		cpi r24, 0			;if not first move and not captured...
00035e f091                      		breq pawn_player_check
                                 
                                 pawn_firstmove_player_check:
00035f 3091                      		cpi r25, 1			;check if player is player 1
000360 f031                      		breq p1_pawn_firstmove
000361 c00a                      		rjmp p2_pawn_firstmove
                                 
                                 jump_rook:
000362 c01a                      		rjmp rook
                                 
                                 jump_knight:
000363 c080                      		rjmp knight
                                 
                                 jump_bishop:
000364 c098                      		rjmp bishop
                                 
                                 jump_queen:
000365 c0c3                      		rjmp queen
                                 
                                 jump_king:
000366 c0cf                      		rjmp king
                                 
                                 p1_pawn_firstmove:
000367 3146                      		cpi r20, 22		;check if it is a forward move of one grid
000368 f099                      		breq jump_checkoccupy
000369 324c                      		cpi r20, 44		;check if it is a forward move of two grids
00036a f0d1                      		breq checkblock_vertical
00036b c1c3                      		rjmp reject_move
                                 
                                 p2_pawn_firstmove:
00036c 3e4a                      		cpi r20, -22	;check if it is a forward move of one grid
00036d f071                      		breq jump_checkoccupy
00036e 3d44                      		cpi r20, -44	;check if it is a forward move of two grids
00036f f0a9                      		breq checkblock_vertical	
000370 c1be                      		rjmp reject_move
                                 
                                 pawn_player_check:
000371 3091                      		cpi r25, 1		;check if player is player 1
000372 f019                      		breq p1_move_pawn
000373 3092                      		cpi r25, 2		;check if player is player 2
000374 f021                      		breq p2_move_pawn
000375 c1b9                      		rjmp reject_move
                                 
                                 p1_move_pawn:
000376 3146                      		cpi r20, 22		;check if it is a forward move of one grid
000377 f021                      		breq jump_checkoccupy
000378 c1b6                      		rjmp reject_move
                                 
                                 p2_move_pawn:
000379 3e4a                      		cpi r20, -22	;check if it is a forward move of one grid
00037a f009                      		breq jump_checkoccupy
00037b c1b3                      		rjmp reject_move
                                 
                                 jump_checkoccupy:
00037c c0ea                      		rjmp checkoccupy
                                 
                                 ;********** ROOK *************
                                 rook:
00037d 5fcf                      		subi YL, $FF		; reset
00037e 0fc0                      		add YL, r16			; Y
00037f e050                      		ldi r21, 0			;flag to show the piece to be moved is not king or pawn
000380 3030                      		cpi r19, 0					;check x-shift = 0
000381 f019                      		breq checkblock_vertical	;check if vertically move upwards or downwards
000382 3040                      		cpi r20, 0					;check y-shift = 0
000383 f021                      		breq checkblock_horizontal	;check if horizontally move to the left or right
000384 9508                      		ret
                                 
                                 ;***************** CHECK BLOCK NON-DIAGONAL ***********
                                 checkblock_vertical:
                                 ;Checks if any pieces are blocking the movement.
000385 1772                      		cp r23, r18		;compare y-coordinate of the chess piece and square square.
000386 f424                      		brge checkblock_vertical_pos ;check upward blocks
000387 c009                      		rjmp checkblock_vertical_neg ;check downward blocks
                                 
                                 checkblock_horizontal:
                                 ;Checks if any pieces are blocking the movement.
000388 1761                      		cp r22, r17
000389 f46c                      		brge checkblock_horizontal_pos ;check right blocks
00038a c012                      		rjmp checkblock_horizontal_neg ;check left blocks
                                 	
                                 checkblock_vertical_pos:
00038b 5146                      		subi r20, 22			;keep shifting until all locations are checked
00038c 3040                      		cpi r20, 0				;if no blocking
00038d f371                      		breq jump_checkoccupy	
00038e 5176                      		subi r23, 22			;shift up one grid
00038f d037                      		rcall checkblock_compare_loop ;compare the shifted coordinates with the coordinates of the pieces in the table
000390 cffa                      		rjmp checkblock_vertical_pos  ;loops checkblock_vertical_pos until there is no blocking or a blocking is found
                                 
                                 checkblock_vertical_neg:		
000391 5e4a                      		subi r20, -22			;keep shifting until all locations are checked
000392 3040                      		cpi r20, 0				;if no blocking
000393 f341                      		breq jump_checkoccupy
000394 5e7a                      		subi r23, -22			;shift down one grid
000395 d031                      		rcall checkblock_compare_loop ;compare the shifted coordinates with the coordinates of the pieces in the table
000396 cffa                      		rjmp checkblock_vertical_neg  ;loops checkblock_vertical_neg until there is no blocking or a blocking is found
                                 
                                 checkblock_horizontal_pos:
000397 5136                      		subi r19, 22			;keep shifting until all locations are checked
000398 3030                      		cpi r19, 0				;if no blocking
000399 f049                      		breq checkblock_check_if_castling_right ;check if the movement is right castling
00039a 5166                      		subi r22, 22			;shift right one grid
00039b d02b                      		rcall checkblock_compare_loop ;compare the shifted coordinates with the coordinates of the pieces in the table
00039c cffa                      		rjmp checkblock_horizontal_pos ;loops checkblock_horizontal_pos until there is no blocking or a blocking is found
                                 
                                 checkblock_horizontal_neg:
00039d 5e3a                      		subi r19, -22			;keep shifting until all locations are checked
00039e 3030                      		cpi r19, 0				;if no blocking
00039f f041                      		breq checkblock_check_if_castling_left ;check if the movement is left castling
0003a0 5e6a                      		subi r22, -22			;shift left one grid
0003a1 d025                      		rcall checkblock_compare_loop ;compare the shifted coordinates with the coordinates of the pieces in the table
0003a2 cffa                      		rjmp checkblock_horizontal_neg ;loops checkblock_horizontal_neg until there is no blocking or a blocking is found
                                 
                                 checkblock_check_if_castling_right:
0003a3 3556                      		cpi r21, 86				;check if the piece to be moved is player 1's king
0003a4 f041                      		breq king_castling_right_rook_confirm_move
0003a5 3656                      		cpi r21, 102			;check if the piece to be moved is player 2's king
0003a6 f031                      		breq king_castling_right_rook_confirm_move
0003a7 cfd4                      		rjmp jump_checkoccupy
                                 
                                 checkblock_check_if_castling_left:	
0003a8 3556                      		cpi r21, 86				;check if the piece to be moved is player 1's king
0003a9 f081                      		breq king_castling_left_rook_confirm_move
0003aa 3656                      		cpi r21, 102			;check if the piece to be moved is player 2's king
0003ab f071                      		breq king_castling_left_rook_confirm_move
0003ac cfcf                      		rjmp jump_checkoccupy
                                 
                                 king_castling_right_rook_confirm_move:
0003ad 1bc0                      		sub YL, r16		;shift Y to the x-coordinate \
0003ae 5fc4                      		subi YL, -12	;of right rook
0003af ee9a                      		ldi r25, -22 
0003b0 8398                      		st Y, r25		;set x-coordinate of right rook to be -22 (y-coordinate unchanged)
0003b1 50cc                      		subi YL, 12		;reset
0003b2 0fc0                      		add YL, r16		;Y
                                 
0003b3 1bc5                      		sub YL, r21		;r21 is index of flag for king.
0003b4 5fca                      		subi YL, -6		;shift to right rook's flag
0003b5 e090                      		ldi r25, 0		
0003b6 8398                      		st Y, r25		;set right rook's flag to 0 (i.e after first-move)
0003b7 50c6                      		subi YL, 6		;reset
0003b8 0fc5                      		add YL, r21		;Y
0003b9 c0f6                      		rjmp confirm_move
                                 	
                                 king_castling_left_rook_confirm_move:
0003ba 1bc0                      		sub YL, r16		;shift Y to the x-coordinate \
0003bb 5fc2                      		subi YL, -14	;of left rook
0003bc e196                      		ldi r25, 22 
0003bd 8398                      		st Y, r25		;set x-coordinate of left rook to be 22 (y-coordinate unchanged)
0003be 50ce                      		subi YL, 14		;reset
0003bf 0fc0                      		add YL, r16		;Y
                                 
0003c0 1bc5                      		sub YL, r21		;r21 is index of flag for king.
0003c1 5fc9                      		subi YL, -7		;shift to left rook's flag
0003c2 e090                      		ldi r25, 0		;
0003c3 8398                      		st Y, r25		;set left rook's flag to 0 (i.e after first-move)
0003c4 50c7                      		subi YL, 7		;reset
0003c5 0fc5                      		add YL, r21		;Y
0003c6 c0e9                      		rjmp confirm_move
                                 
                                 
                                 ;*********** CHECK FOR BLOCK (called by Rook, Bishop, Queen, Pawn) ***********
                                 checkblock_compare_loop: 
0003c7 e480                      		ldi r24, 64 ;total no of coordinates of all pieces
0003c8 50c6                      		subi YL, 6	;shift Y to x-coordiante of first chess piece 
0003c9 d001                      		rcall checkblock_compare_x	;compare x-coordinate of the selected chess piece with x coordiantes of chess pieces in the table
0003ca 9508                      		ret
                                 
                                 checkblock_compare_x:
                                 ;compare x-coordinate of the selected chess piece with x coordiantes of chess pieces in the table
0003cb 919a                      		ld r25, -Y	;load x-coordiante of chess piece
0003cc 958a                      		dec r24	
0003cd 1769                      		cp r22, r25 ;compare x-coordinates
0003ce f021                      		breq checkblock_compare_y ;if the selected piece's x-coordinate is equal to the x-coordinate of a piece in the table, go to checkblock_compare_y which compares their y-coordinates
0003cf 50c1                      		subi YL,1	;shifts Y to y-coordinate of chess piece
0003d0 958a                      		dec r24
0003d1 f041                      		breq checkblock_reset	;if no blocking is found, reset Y and return
0003d2 cff8                      		rjmp checkblock_compare_x ;loops checkblock_compare_x until all pieces are checked
                                 
                                 checkblock_compare_y:
                                 ;compare x-coordinate of the selected chess piece with x coordiantes of chess pieces in the table
0003d3 958a                      		dec r24
0003d4 919a                      		ld r25, -Y ;load y-coordiante of chess piece
0003d5 1779                      		cp r23, r25 ;compare y-coordinates
0003d6 f029                      		breq checkblock_rejectmove ;if the selected piece's y-coordinate is equal to the y-coordinate a piece in the table, reset Y and reject move
0003d7 3080                      		cpi r24, 0
0003d8 f009                      		breq checkblock_reset ;if no blocking is found, reset Y and return
0003d9 cff1                      		rjmp checkblock_compare_x ;loops checkblock_compare_x until all pieces are checked
                                 
                                 checkblock_reset:
0003da 5bca                      		subi YL, $BA; shift pointer Y by +70 (reset)
0003db 9508                      		ret
                                 
                                 checkblock_rejectmove:
0003dc 5485                      		subi r24, 69
0003dd 5fcf                      		subi YL, $FF ;reset
0003de 1bc8                      		sub YL, r24  ;Y
                                 		;sequence of pops to offset the two rcalls
0003df 918f                      		pop r24
0003e0 918f                      		pop r24
0003e1 918f                      		pop r24
0003e2 918f                      		pop r24
0003e3 c14b                      		rjmp reject_move
                                 
                                 ;*********** KNIGHT ***********
                                 knight:
0003e4 5fcf                      		subi YL, $FF ;reset
0003e5 0fc0                      		add YL, r16	 ;Y
0003e6 e050                      		ldi r21, 0			;flag to show the piece to be moved is not king or pawn
0003e7 323c                      		cpi r19, 44			;check is there is a horizontal move of two grids to the right
0003e8 f039                      		breq knight_check1
0003e9 3d34                      		cpi r19, -44
0003ea f029                      		breq knight_check1  ;check is there is a horizontal move of two grids to the left
0003eb 3136                      		cpi r19, 22
0003ec f041                      		breq knight_check2	;check is there is a horizontal move of one grid to the right
0003ed 3e3a                      		cpi r19, -22
0003ee f031                      		breq knight_check2	;check is there is a horizontal move of one grid to the left
0003ef c13f                      		rjmp reject_move
                                 
                                 knight_check1:
0003f0 3146                      		cpi r20, 22				;check is there is a vertical move of one grid upwards
0003f1 f041                      		breq jump_checkoccupy1
0003f2 3e4a                      		cpi r20, -22			;check is there is a vertical move of one grid downwards
0003f3 f031                      		breq jump_checkoccupy1
0003f4 c13a                      		rjmp reject_move
                                 
                                 knight_check2:
0003f5 324c                      		cpi r20, 44				;check is there is a vertical move of two grids upwards
0003f6 f019                      		breq jump_checkoccupy1
0003f7 3d44                      		cpi r20, -44			;check is there is a vertical move of two grids downwards
0003f8 f009                      		breq jump_checkoccupy1
0003f9 c135                      		rjmp reject_move
                                 
                                 jump_checkoccupy1:
0003fa c06c                      		rjmp checkoccupy
                                 
                                 jump_checkblock_vertical:
0003fb cf89                      		rjmp checkblock_vertical
                                 
                                 jump_checkblock_horizontal:
0003fc cf8b                      		rjmp checkblock_horizontal
                                 
                                 ;********* BISHOP ***********
                                 bishop:
0003fd 5fcf                      		subi YL, $FF ;reset
0003fe 0fc0                      		add YL, r16	 ;Y
0003ff e050                      		ldi r21, 0	 ;flag to show the piece to be moved is not king or pawn
000400 1734                      		cp r19, r20  ;check shift is along the x = y line
000401 f021                      		breq checkblock_xy
000402 9531                      		neg r19		;take the negative of r19
000403 1734                      		cp r19, r20 ;check shift is along the x = -y line
000404 f021                      		breq checkblock_xy_opp
000405 c129                      		rjmp reject_move
                                 
                                 ;********* CHECK BLOCK DIAGONAL ***********	
                                 checkblock_xy: ;x=y line
000406 1761                      		cp r22, r17				;compare x-coordinate of the selected chess piece with x-coordiante of the square. If r22 > r17, check blocks on RHS. otherwise, check blocks on LHS.
000407 f42c                      		brge checkblock_xy_right 
000408 c00b                      		rjmp checkblock_xy_left
                                 
                                 checkblock_xy_opp: ;x=-y line
000409 9531                      		neg r19
00040a 1761                      		cp r22, r17				;compare x-coordinate of the selected chess piece with x-coordiante of the square. If r22 > r17, check blocks on RHS. otherwise, check blocks on LHS.
00040b f47c                      		brge checkblock_xy_opp_right
00040c c015                      		rjmp checkblock_xy_opp_left
                                 
                                 checkblock_xy_right:
00040d 5136                      		subi r19, 22			;keep shifting until all locations are checked
00040e 3030                      		cpi r19, 0				;if no blocking
00040f f351                      		breq jump_checkoccupy1	
000410 5166                      		subi r22, 22			;shift right one grid
000411 5176                      		subi r23, 22			;shift up one grid
000412 dfb4                      		rcall checkblock_compare_loop ;compare the shifted coordinates with the coordinates of the pieces in the table
000413 cff9                      		rjmp checkblock_xy_right	;loops checkblock_xy_right until all pieces are compared
                                 
                                 checkblock_xy_left:
000414 5e3a                      		subi r19, -22			;keep shifting until all locations are checked
000415 3030                      		cpi r19, 0				;if no blocking
000416 f319                      		breq jump_checkoccupy1	
000417 5e6a                      		subi r22, -22			;shift left one grid
000418 5e7a                      		subi r23, -22			;shift down one grid
000419 dfad                      		rcall checkblock_compare_loop ;compare the shifted coordinates with the coordinates of the pieces in the table
00041a cff9                      		rjmp checkblock_xy_left	;loops checkblock_xy_left until all pieces are compared
                                 
                                 checkblock_xy_opp_right:
00041b 5136                      		subi r19, 22			;keep shifting until all locations are checked
00041c 3030                      		cpi r19, 0				;if no blocking
00041d f2e1                      		breq jump_checkoccupy1
00041e 5166                      		subi r22, 22			;shift right one grid
00041f 5e7a                      		subi r23, -22			;shift down one grid
000420 dfa6                      		rcall checkblock_compare_loop	;compare the shifted coordinates with the coordinates of the pieces in the table
000421 cff9                      		rjmp checkblock_xy_opp_right	;loops checkblock_xy_left until all pieces are compared
                                 
                                 checkblock_xy_opp_left:
000422 5e3a                      		subi r19, -22			;keep shifting until all locations are checked
000423 3030                      		cpi r19, 0				;if no blocking
000424 f2a9                      		breq jump_checkoccupy1
000425 5e6a                      		subi r22, -22			;shift left one grid
000426 5176                      		subi r23, 22			;shift up one grid
000427 df9f                      		rcall checkblock_compare_loop	;compare the shifted coordinates with the coordinates of the pieces in the table
000428 cff9                      		rjmp checkblock_xy_opp_left		;loops checkblock_xy_opp_left until all pieces are compared
                                 
                                 ;********** QUEEN ***************
                                 queen:
000429 5fcf                      		subi YL, $FF	;reset
00042a 0fc0                      		add YL, r16		;Y
00042b e050                      		ldi r21, 0		;flag to show the piece to be moved is not king or pawn
00042c 3030                      		cpi r19, 0		;check if move is vertical
00042d f269                      		breq jump_checkblock_vertical
00042e 3040                      		cpi r20, 0		;check if move is horizontal
00042f f261                      		breq jump_checkblock_horizontal
000430 1734                      		cp r19, r20		;check move is a shift is along the x = y line
000431 f2a1                      		breq checkblock_xy
000432 9531                      		neg r19
000433 1734                      		cp r19, r20		;check move is a shift is along the x = -y line
000434 f2a1                      		breq checkblock_xy_opp
000435 c0f9                      		rjmp reject_move
                                 
                                 ;********** KING ****************
                                 king:
000436 5fcf                      		subi YL, $FF	;reset
000437 0fc0                      		add YL, r16		;Y
                                 
000438 2f50                      		mov r21, r16	;copy the index of selected piece's x-coordinate to r21
000439 5057                      		subi r21, 7		
00043a 9556                      		lsr r21			;divide by 2 by shifting bits
00043b 5b59                      		subi r21, $B9	;plus 71
00043c 1bc5                      		sub YL, r21		;r21 is index of king's flag
00043d 8188                      		ld r24, Y		;king's flag
00043e 0fc5                      		add YL, r21		;reset Y
                                 
00043f 3040                      		cpi r20, 0		;check if not moving vertically
000440 f029                      		breq king_check_castling
000441 3146                      		cpi r20, 22		;check if move up by 1 grid
000442 f049                      		breq king_check_horizontal
000443 3e4a                      		cpi r20, -22	;check if move down by 1 grid
000444 f039                      		breq king_check_horizontal
000445 c0e9                      		rjmp reject_move
                                 
                                 king_check_castling:
000446 3082                      		cpi r24, 2		;check if it is king's first move
000447 f421                      		brne king_check_horizontal
000448 323c                      		cpi r19, 44		;check if move right by 2 grid
000449 f099                      		breq king_castling_right
00044a 3d34                      		cpi r19, -44	;check if move left by 2 grid
00044b f039                      		breq king_castling_left
                                 
                                 king_check_horizontal:
00044c 3030                      		cpi r19, 0	 ;check if not moving horizontally
00044d f0c9                      		breq checkoccupy
00044e 3136                      		cpi r19, 22  ;check if move right by 1 grid
00044f f0b9                      		breq checkoccupy
000450 3e3a                      		cpi r19, -22 ;check if move left by 1 grid
000451 f0a9                      		breq checkoccupy
000452 c0dc                      		rjmp reject_move
                                 
                                 king_castling_left:
000453 1bc5                      		sub YL, r21		;shift Y to the flag\
000454 5fc9                      		subi YL, -7		;of left rook
000455 8198                      		ld r25, Y		;load flag of left rook
000456 50c7                      		subi YL, 7		;reset
000457 0fc5                      		add YL, r21		;Y
000458 e082                      		ldi  r24, 2	
000459 1398                      		cpse r25, r24	;check if it is first move of left rook
00045a c0d4                      		rjmp reject_move
00045b 523c                      		subi r19, 44	;increases the range of checkblock. so checkblock for both king and rook at the same time.
00045c cf2b                      		rjmp checkblock_horizontal
                                 
                                 king_castling_right:
00045d 1bc5                      		sub YL, r21		;shift Y to the flag\
00045e 5fca                      		subi YL, -6		;of right rook
00045f 8198                      		ld r25, Y		;load flag of right rook
000460 50c6                      		subi YL, 6		;reset
000461 0fc5                      		add YL, r21		;Y
000462 e082                      		ldi  r24, 2
000463 1398                      		cpse r25, r24	;check if it is first move of right rook
000464 c0ca                      		rjmp reject_move
000465 5e3a                      		subi r19, -22	;increases the range of checkblock. so checkblock for both king and rook at the same time.
000466 cf21                      		rjmp checkblock_horizontal
                                 
                                 	
                                 ;******** CHECK IF GRID IS OCCUPIED *************
                                 checkoccupy:
000467 50c2                      		subi YL, 2	 ;shift Y to play flag
000468 8188                      		ld r24, Y	 ;load player flag to r24
000469 50c4                      		subi YL, 4	 ;shift Y to x-coordinate of first chess piece in the table
00046a e440                      		ldi r20, 64  ;r20 is the total no of coordinates of all pieces
00046b c00c                      		rjmp checkoccupy_compare_x
                                 
                                 checkoccupy_nooccupy:
00046c 5bca                      		subi YL, $BA ;shift pointer Y by +70 (reset)
00046d 3556                      		cpi r21, 86
00046e f029                      		breq jump_confirm_move
00046f 3656                      		cpi r21, 102
000470 f1f9                      		breq confirm_move
000471 3050                      		cpi r21, 0		;check if pawn. r21 = 0 if not pawn
000472 f411                      		brne pawn_nooccupy_check_diagonal
000473 c03c                      		rjmp confirm_move
                                 
                                 jump_confirm_move:
000474 c03b                      		rjmp confirm_move
                                 
                                 pawn_nooccupy_check_diagonal:
000475 3030                      		cpi r19, 0		;if x-shift is 0 -> not diagonal move
000476 f1c9                      		breq confirm_move
000477 c0b7                      		rjmp reject_move	
                                 
                                 checkoccupy_compare_x:
                                 ;compare x-coordinate of the selected chess piece with x coordiantes of chess pieces in the table
000478 916a                      		ld r22, -Y		;load x-coordiante of chess piece
000479 954a                      		dec r20
00047a 1716                      		cp r17, r22		;compare x-coordinates
00047b f021                      		breq checkoccupy_compare_y ;if the selected piece's x-coordinate is equal to the x-coordinate of a piece in the table, go to checkblock_compare_y which compares their y-coordinates
00047c 50c1                      		subi YL, 1		;shifts Y to y-coordinate of chess piece
00047d 954a                      		dec r20
00047e f369                      		breq checkoccupy_nooccupy  ;if no blocking is found, go to checkoccupy_nooccupy
00047f cff8                      		rjmp checkoccupy_compare_x ;loops checkoccupy_compare_x until all pieces are checked
                                 	
                                 checkoccupy_compare_y:
                                 ;compare y-coordinate of the selected chess piece with x coordiantes of chess pieces in the table
000480 954a                      		dec r20
000481 917a                      		ld r23, -Y		;load y-coordiante of chess piece
000482 1727                      		cp r18, r23		;compare y-coordinates
000483 f019                      		breq checkoccupy_occupied ;if the selected piece's y-coordinate is equal to the y-coordinate a piece in the table, go to checkoccupy_occupied
000484 3040                      		cpi r20, 0
000485 f331                      		breq checkoccupy_nooccupy  ;if no blocking is found,  go to checkoccupy_nooccupy
000486 cff1                      		rjmp checkoccupy_compare_x ;loops checkblock_compare_x until all pieces are checked
                                 
                                 checkoccupy_occupied:
000487 3240                      		cpi r20, 32 ;if occupied by player 1's pieces
000488 f40c                      		brge checkoccupy_occupied_check_player1
000489 c004                      		rjmp checkoccupy_occupied_check_player2
                                 
                                 checkoccupy_occupied_check_player1:
00048a d012                      		rcall checkoccupy_reset
00048b 3081                      		cpi r24, 1			;r24 = player 1 or 2 flag. If player 1...
00048c f079                      		breq jump_reject_move
00048d c004                      		rjmp check_if_pawn
                                 
                                 checkoccupy_occupied_check_player2:
00048e d00e                      		rcall checkoccupy_reset
00048f 3082                      		cpi r24, 2			;r24 = player 1 or 2 flag. If player 2...
000490 f059                      		breq jump_reject_move
000491 c000                      		rjmp check_if_pawn
                                 
                                 check_if_pawn:
000492 3556                      		cpi r21, 86
000493 f071                      		breq setcapturedflag
000494 3656                      		cpi r21, 102
000495 f061                      		breq setcapturedflag
000496 3050                      		cpi r21, 0	;check if pawn. r21 = 0 if not pawn
000497 f409                      		brne pawn_yesoccupy_check_vertical
000498 c009                      		rjmp setcapturedflag
                                 
                                 pawn_yesoccupy_check_vertical:
000499 3030                      		cpi r19, 0		;if x-shift is 0 -> vertical move
00049a f009                      		breq jump_reject_move
00049b c006                      		rjmp setcapturedflag
                                 
                                 jump_reject_move:
00049c c092                      		rjmp reject_move
                                 
                                 checkoccupy_reset:
00049d 5445                      		subi r20, 69		;r20 is now the index of x-coordinate of captured chess piece (r20 is negative)
00049e 9541                      		neg r20
00049f 5fcf                      		subi YL, $FF		;reset due to pre-decrement
0004a0 0fc4                      		add YL, r20			;reset YL
0004a1 9508                      		ret
                                 
                                 setcapturedflag:
0004a2 1bc4                      		sub YL, r20		;shift Y to x-coordinate of captured piece 
0004a3 e09a                      		ldi r25, 10		;new coordinate for dead pieces
0004a4 8398                      		st Y, r25		;dead piece now has 10 for x-coordinate
0004a5 95ca                      		dec YL			;shift Y to y-coordinate of captured piece
0004a6 8398                      		st Y,r25		;dead piece now has 10 for y-coordinate
0004a7 95c3                      		inc YL			;reset
0004a8 0fc4                      		add YL, r20		;Y
                                 						;convert r20 (x-coordinate index of captured piece) into index of capture flag of the dead piece
0004a9 5047                      		subi r20, 7		;1) r20 minus 7 so that the first capture piece's x-coordinate corresponds to r20 = 0
0004aa 9546                      		lsr r20			;2) divide by 2 by shifting 1 bit to the right
0004ab 5b49                      		subi r20, $B9	;3) plus 71 so r20 is now index of capture flag of dead piece
0004ac 1bc4                      		sub YL, r20		;Y is now at the capture flag of the dead piece
0004ad e091                      		ldi r25, 1
0004ae 8398                      		st Y, r25		;Set capture flag of dead piece to 1 (makes the piece dead)
0004af 0fc4                      		add YL, r20		;Reset Y
                                 
                                 confirm_move:
0004b0 1bc0                      		sub YL, r16	;Y is shifted to the x-coordinate of the selected chess piece
0004b1 8318                      		st Y, r17	;overwrite x-coordinate to square x-coordinate
0004b2 95ca                      		dec YL
0004b3 8328                      		st Y, r18	;overwrite y-coordinate to square y-coordinate
0004b4 5fcf                      		subi YL, $FF ; reset
0004b5 0fc0                      		add YL, r16	; Y
0004b6 3050                      		cpi r21, 0		;if a piece that's not pawn is moved
0004b7 f029                      		breq set_to_selectpiece
                                 
                                 firstmove_flagchange:
0004b8 1bc5                      		sub YL, r21		;r21 is index of flag for pawn/king. r21 = 0 for other pieces.
0004b9 e090                      		ldi r25, 0		
0004ba 8398                      		st Y, r25		;set flag to 0 (i.e after first-move)
0004bb 0fc5                      		add YL, r21		;reset Y
0004bc c000                      		rjmp set_to_selectpiece
                                 
                                 set_to_selectpiece:		;change the 'select or move' flag to 0
0004bd 50c3                      		subi YL, 3	;shift Y to 'select piece' flag
0004be e090                      		ldi r25, 0 
0004bf 8398                      		st Y, r25	;set 'select or move' flag to 0 (i.e. change to select piece)
0004c0 5fcd                      		subi YL, $FD	;reset Y
0004c1 918a                      		ld r24, -Y		;emoticon flag
0004c2 95c3                      		inc YL			;reset Y
                                 
                                 checkwin:
0004c3 55c6                      		subi YL, 86		;move to player 1 king capture flag
0004c4 8198                      		ld r25, Y		;store capture flag value to r25
0004c5 5aca                      		subi YL, $AA	;reset Y (+86)
0004c6 3091                      		cpi r25, 1		;if game is won
0004c7 f031                      		breq win_message
                                 
0004c8 56c6                      		subi YL, 102	;move to player 2 king capture flag
0004c9 8198                      		ld r25, Y		;store capture flag value to r25
0004ca 59ca                      		subi YL, $9A	;reset Y (+102)
0004cb 3091                      		cpi r25, 1		;if game is won
0004cc f009                      		breq win_message
0004cd c010                      		rjmp set_to_selectpiece_cont
                                 
                                 win_message:
                                 ;Display WIN message on the LCD screen. Also removes the 'sad face' on the LCD screen.
0004ce e090                      		ldi r25, 0		;used to compare on next line
0004cf 1389                      		cpse r24, r25	;skip 'clearface' function if no emoticon is displayed on the LCD screen
0004d0 d012                      		rcall jump_clearface
                                 
0004d1 e597                      		ldi r25, $57	; W
0004d2 9390 c000                 		sts $C000, r25
0004d4 dcb0                      		rcall busylcd
0004d5 e499                      		ldi r25, $49	; I
0004d6 9390 c000                 		sts $C000, r25
0004d8 dcac                      		rcall busylcd
0004d9 e49e                      		ldi r25, $4E	; N
0004da 9390 c000                 		sts $C000, r25
0004dc dca8                      		rcall busylcd
                                 
0004dd 9508                      		ret
                                 
                                 set_to_selectpiece_cont:
0004de 50c2                      		subi YL,2				;shift Y to player flag
0004df 8198                      		ld r25, Y				;load player flag to r25
0004e0 3091                      		cpi r25, 1				;if player 1
0004e1 f0b9                      		breq jump_set_player2	;change to player 2 by changing flag
0004e2 c001                      		rjmp set_player1		;if player is player 2, change to player 1 by changing flag
                                 	
                                 
                                 jump_clearface:
0004e3 c016                      		rjmp clearface
                                 
                                 set_player1:
0004e4 e001                      		ldi r16, 1		
0004e5 8308                      		st Y, r16		;update player flag to 1
0004e6 5fce                      		subi YL, $FE	;reset Y
                                 	
0004e7 e010                      		ldi r17, 0
0004e8 1381                      		cpse r24, r17	;if emoticon is not on the LCD screen
0004e9 d010                      		rcall clearface	;clear the sad face if it's on the screen
                                 
0004ea e190                      		ldi r25, $10	 
0004eb 9390 8000                 		sts $8000, r25	;shift left 
0004ed dc97                      		rcall busylcd
0004ee 9390 8000                 		sts $8000, r25	;shift left 
0004f0 dc94                      		rcall busylcd
0004f1 e391                      		ldi r25, $31	;write '1'
0004f2 9390 c000                 		sts $C000, r25
0004f4 dc90                      		rcall busylcd
0004f5 e290                      		ldi r25, $20	;spacebar
0004f6 9390 c000                 		sts $C000, r25
0004f8 9508                      		ret
                                 
                                 jump_set_player2:
0004f9 c020                      		rjmp set_player2
                                 
                                 clearface:
0004fa 95ca                      		dec YL			;shift Y to emoticon flag
0004fb e090                      		ldi r25, 0		
0004fc 8398                      		st Y, r25		;set emoticon flag to 0. flag 0 = no face	
0004fd 95c3                      		inc YL			;reset Y
                                 
0004fe e190                      		ldi r25, $10	
0004ff 9390 8000                 		sts $8000, r25	;shift left 
000501 dc83                      		rcall busylcd
000502 9390 8000                 		sts $8000, r25	;shift left 
000504 dc80                      		rcall busylcd
000505 9390 8000                 		sts $8000, r25	;shift left 
000507 dc7d                      		rcall busylcd
000508 e290                      		ldi r25, $20	
000509 9390 c000                 		sts $C000, r25	;write space
00050b dc79                      		rcall busylcd
00050c 9390 c000                 		sts $C000, r25	;write space
00050e dc76                      		rcall busylcd
00050f 9390 c000                 		sts $C000, r25	;write space
000511 dc73                      		rcall busylcd	
000512 e190                      		ldi r25, $10
000513 9390 8000                 		sts $8000, r25 	;shift left 
000515 dc6f                      		rcall busylcd
000516 9390 8000                 		sts $8000, r25	;shift left 
000518 dc6c                      		rcall busylcd
000519 9508                      		ret
                                 
                                 set_player2:
00051a e002                      		ldi r16, 2		
00051b 8308                      		st Y, r16		 ;update flag to 2 for player 2
00051c 5fce                      		subi YL, $FE	 ;reset Y
                                 
00051d e010                      		ldi r17, 0
00051e 1381                      		cpse r24, r17	;skip clearface function if emoticon is not on the LCD screen
00051f dfda                      		rcall clearface	;clear the sad face if it's on the screen
                                 
000520 e190                      		ldi r25, $10
000521 9390 8000                 		sts $8000, r25	;shift left 
000523 dc61                      		rcall busylcd
000524 9390 8000                 		sts $8000, r25	;shift left 
000526 dc5e                      		rcall busylcd
000527 e392                      		ldi r25, $32	;write '2'
000528 9390 c000                 		sts $C000, r25
00052a dc5a                      		rcall busylcd
00052b e290                      		ldi r25, $20	;write space
00052c 9390 c000                 		sts $C000, r25
00052e 9508                      		ret
                                 
                                 reject_move:
00052f 919a                      		ld r25, -Y		;shift Y to emoticon flag
000530 e081                      		ldi r24, 1		;used to compare if emoticon flag is 1
000531 1398                      		cpse r25, r24	;if LCD screen is showing sad face, skip next line
000532 d002                      		rcall sadface	;if no face on the LCD screen, display a sad face to indicate an illegal move.
000533 95c3                      		inc YL			;reset Y
000534 9508                      		ret
                                 
                                 sadface:
000535 e091                      		ldi r25, 1		
000536 8398                      		st Y, r25		;set emoticon flag to 1
000537 e39a                      		ldi r25, $3A	;write ':'
000538 9390 c000                 		sts $C000, r25
00053a dc4a                      		rcall busylcd
00053b e298                      		ldi r25, $28	;write '('
00053c 9390 c000                 		sts $C000, r25
00053e dc46                      		rcall busylcd
00053f 9508                      		ret
                                 
                                 IO1:	; ******* Port E setup Code ****  
000540 ef00                      		ldi r16, $F0		; 0-3 output, 4-7 input
000541 b902                      		out DDRE, r16		; Port E Direction Register
000542 e00f                      		ldi r16, $0F		; Init value 
000543 b903                      		out PORTE, r16		; Port E value
000544 9508                      		ret
                                 
                                 IO2:	; ******* Port E setup Code ****  
000545 e00f                      		ldi r16, $0F		; 0-3 input, 4-7 output
000546 b902                      		out DDRE, r16		; Port E Direction Register
000547 ef00                      		ldi r16, $F0		; Init value 
000548 b903                      		out PORTE, r16		; Port E value
000549 9508                      		ret
                                 
                                 ;
                                 ;********************   DELAY ROUTINES ********************************************
                                 ;
                                 DEL10ms:
                                 ; This is a 10 msec delay routine. Each cycle costs
                                 ; rcall           -> 3 CC
                                 ; ret              -> 4 CC
                                 ; 2*LDI        -> 2 CC 
                                 ; SBIW         -> 2 CC * 19997
                                 ; BRNE        -> 2 CC * 19997
                                 
00054a e4fe                                  LDI ZH, HIGH(19997)
00054b e1ed                                  LDI ZL, LOW (19997)
                                 COUNT:  
00054c 9731                                  SBIW ZL, 1
00054d f7f1                                  BRNE COUNT
00054e 9508                                  RET
                                 ;
                                 DEL4P1ms:
00054f e2f0                                  LDI ZH, HIGH(8198)
000550 e0e6                                  LDI ZL, LOW (8198)
                                 COUNT1:
000551 9731                                  SBIW ZL, 1
000552 f7f1                                  BRNE COUNT1
000553 9508                                  RET 
                                 ;
                                 DEL100mus:
000554 e0f0                                  LDI ZH, HIGH(198)
000555 ece6                                  LDI ZL, LOW (198)
                                 COUNT2:
000556 9731                                  SBIW ZL, 1
000557 f7f1                                  BRNE COUNT2
000558 9508                                  RET 
                                 
                                 DEL5mus:	
000559 e0f0                                  LDI ZH, HIGH(8)
00055a e0e8                                  LDI ZL, LOW (8)
                                 COUNT3:
00055b 9731                                  SBIW ZL, 1
00055c f7f1                                  BRNE COUNT3
00055d 9508                                  RET 
                                 
                                 
                                 
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :  20 y  :  58 z  :   0 r0 :   4 r1 :   0 r2 :   0 r3 :   0 r4 :   2 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 141 r17:  41 r18:  45 r19: 108 r20:  48 
r21:  41 r22:  22 r23:  14 r24:  45 r25:  91 r26:  23 r27:   4 r28: 110 
r29:   4 r30:  15 r31:   9 
Registers used: 20 out of 35 (57.1%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  39 adiw  :   0 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  96 brge  :  21 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :  18 brmi  :   0 
brne  :  28 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   1 cbi   :   0 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   2 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :  14 cpc   :   0 
cpi   : 121 cpse  :  10 dec   :  35 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :   3 inc   :   7 
jmp   :   2 ld    :  54 ldd   :   0 ldi   : 113 lds   :   1 lpm   :   6 
lsl   :   0 lsr   :   3 mov   :   4 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   5 nop   :  22 or    :   0 ori   :   0 out   :  40 
pop   :  20 push  :  16 rcall :  59 ret   :  42 reti  :  23 rjmp  :  83 
rol   :   0 ror   :   0 sbc   :   0 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   4 sbr   :   0 sbrc  :   1 sbrs  :   0 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :  24 std   :   0 
sts   :  32 sub   :  18 subi  : 116 swap  :   0 tst   :   0 wdr   :   0 

Instructions used: 36 out of 114 (31.6%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000abc   2232    356   2588  131072   2.0%
[.dseg] 0x000100 0x000100      0      0      0    4096   0.0%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 1 warnings
